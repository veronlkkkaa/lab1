# Лабораторная работа №1

**Выполнила:** Гаврилович Вероника Вячеславовна  
**Группа:** Р3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure  

---

## Задача 9
**Условие:** **Пифагорова тройка** — это набор из трёх натуральных чисел `a < b < c`, для которого:  
`a² + b² = c²`.

### Ключевые элементы реализации
Были разработаны следующие варианты решений:

- `tail-rec` — монолитная реализация с хвостовой рекурсией  
- `solve-rec` — монолитная реализация с обычной рекурсией  
- `solve-modular` — модульная реализация  
- `solve-with-map` — реализация с акцентом на `map`  
- `solve-lazy` — реализация с бесконечными последовательностями и ленивыми вычислениями  

**Алгоритм решения:**

1. Перебираю a от 1 до примерно 333 (1000 / 3), потому что если a будет больше, то b и c уже не смогут быть больше него.
2. Для каждого a перебираю b от a + 1 до 500 (1000 / 2), так как b должен быть больше a, но меньше c.
3. Вычисляю c по формуле: c = 1000 - a - b.
    Проверяю два условия:
    3.1. c действительно больше b
    3.2. Выполняется равенство a² + b² == c²
4. Возвращаю произведение a * b * c.
    Если вдруг ничего не найдено (хотя в этой задаче это невозможно), возвращаю -1.

---

## Задача 21
**Условие:** Пусть `d(n)` можно определить как сумму собственных делителей `n` (числа меньше, чем `n`, которые равномерно делятся на `n`).
Если `d(a) = b` и `d(b) = a`, где `a ≠ b`, тогда `a` и `b` — дружная пара, и каждый из них (`a` и `b`) называется дружественным числом.

### Ключевые элементы реализации
Были разработаны следующие варианты решений:

- `solve-tail-rec` — монолитная реализация с хвостовой рекурсией  
- `solve-rec` — монолитная реализация с обычной рекурсией  
- `solve-modular` — модульная реализация  
- `count-letters-with-map` — реализация с акцентом на `map`  
- `solve-lazy` — реализация с бесконечными последовательностями и ленивыми вычислениями  

**Алгоритм решения:**

1. Перебираю все числа от 1 до 9999.
2. Для каждого числа n:
    2.1. Считаю сумму его собственных делителей → называю это d(n).
    2.2. Проверяю, что d(n) ≠ n (иначе это совершенное число, не дружественное).
    2.3. Считаю d(d(n)) — сумму делителей от d(n).
        Если d(d(n)) == n, то n — часть дружественной пары.
3. Такое n добавляю к общей сумме.
Важно: я добавляю только n, а не оба числа пары — потому что при переборе второе число тоже будет рассмотрено отдельно, и тогда оно само добавится. Но на самом деле в этом алгоритме каждая пара учитывается один раз, так как условие симметрично и мы идём по порядку.

---

## Выводы
В данной лабораторной работе я познакомилась с синтаксисом языка **Clojure** и его базовыми возможностями.  
Я изучила функции, объявления, свертку, отображение, работу со списками и рекурсией (хвостовой и обычной).  

Также были реализованы решения на языке **Python**, которые использовались для сравнения и тестирования.

